This project strictly adheres to responsible disclosure regarding the use of AI tools in its development.

The primary objective of this project is to deepen my practical and theoretical knowledge of C programming, specifically applied to Embedded Linux. Because understanding the low-level mechanics is the entire point, treating AI as a ghostwriter fundamentally defeats the purpose.

However, AI has been an invaluable asset for navigating the steep learning curve of systems programming, discovering industry best practices, and debugging complex memory or architecture issues. To balance modern tooling with rigorous learning, all AI usage in this project is governed by the following four pillars:

1. **Comprehension Over Completion (Zero Black-Box Code)**: The goal is to understand, not just to finish. I must comprehend the function and memory implications of every single line of code before it enters this codebase. AI is used to understand the "why" behind the syntax and concepts, never to bypass the learning curve.

2. **The Developer is the Driver**: I write the architectural outlines, guide the central logic and implement the code, while using AI to steer me towards best-practices, to teach me about new (to me) concepts and to do that initial validation before the build to catch the really stupid bugs. It suggests how to navigate, but my hands are on the steering wheel.

3. **Iron Sharpens Iron (Encouraging Friction)**: AI tools used in this project are explicitly prompted to act as strict senior reviewers. They are instructed to actively disagree, flag unsafe C practices, point out inefficiencies, and enforce industry best practices, rather than simply validating my current approach.

By enforcing these boundaries, this project ensures that the code remains securely mine, while safely leveraging AI to write cleaner, more robust, and production-minded C; while also teaching me to use this wonderful language from the fundamentals to the industry-standards.
